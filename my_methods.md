## Plan_A

### 1.算法框架

* （1）从程序中提取出中全局变量访问的信息，包括但不限于：[==访问方式==，==线程状态==，==锁集合==，==位置信息==，==函数调用栈==]等。

  * 线程状态包括线程集合以及threadStatus

  * 不使用BAM对CFA进行展开，**$\color{red}将线程创建视作函数调用$**（应该是特殊的函数调用），在展开的过程中提取访问信息。

  * 状态的覆盖关系中，利用线程状态和锁集合进行判断：

    $$ 若threadState(e_1)\ \ \sqsubseteq \ \ threadState(e_2)且lockState(e_1) \ \ \sqsubseteq\ \ lockState(e_2)，则e_1\sqsubseteq e_2，e_2\ \ \ cover\ \ e_1 $$

  * ==同名线程的创建尝试加以区分==，以t1为例，对于线程内的访问信息来说，第一次创建为t1_1，第二次创建为t1_2，对于主线程来说都为t1。

* （2）利用MHP分析筛选出可能存在race的访问对，MHP候选：`happen-before`。

* （3）$\color{red}对于可能存在race的pair，计算路径可达性$，若均可达，则报出race，否则需要进一步细化。
  * 无法找到所有可能的访问路径，因此此方案更倾向于找错
  * 对于初次判定不可达的race：
    * A.利用false race的路径产生的新谓词，重新开始继续迭代
    * B.不从头开始迭代，只关注false race的情况（找到路径不可达的原因，从对应位置处重新开始）

**可能的细化策略**：

* ==将不可行的race视作ERROR标签，变成多ERROR标签可达任务==
* ==ERROR标签匹配策略，单label（race中有一条路径不可达）和双label不同处理==



## Plan_B

算法框架与Plan_A类似，不同之处在于：

* ==在CFA展开过程中，只要发现一对可能的race就进行可行性分析==



## Plan_C

==**Step1**==:**可达图的探索**，考虑线程之间的交互，以完全展开的方式进行

**要点**：

:one:	包含Location覆盖和以BDD为基础的可达域覆盖，但是Location的优先级高于BDD，即Location覆盖出现时，该处的可达图探索一定会暂时停止，没有Location覆盖时，是否继续往下探索取决于BDD是否覆盖

* BDD覆盖决定空间是否完全探索以及及时停止
* Location覆盖能够在确保全局变量访问信息被提取到的同时，不用重复探索相同位置

:two:	Location覆盖的条件：若状态$l_1$被覆盖，则$l_1$中的所有位置均已被探索过（在存放探索位置的数据结构中能够找到）

:three:	一边展开CFA一遍抽取关于全局变量的访问信息，若发现了$race\  pair$，则检查是否为真$race$



==**Step2**==：**$race$检查**，当发现对相同全局变量的两次访问时，检查两次访问是否有可能同时发生，可选的方法：$\color{green}{检查对应的两条迁移是否具有相同的前缀路径}$，$ \color{green}{happen-before分析}$，$ \color{green}{锁集法}$

**==Step3==**：若$race$为真，则算法退出，否则：

* 若可达图已经探索完毕，且没有被cover的状态，则算法退出，表明该算法下不存在$race$
* 若可达图已经探索完毕，但存在被cover的状态，则将covered的状态放回waiting list中，清空（或部分清空）存储已探索位置的数据结构，然后继续探索状态空间
* 若可达图没有探索完，则继续探索

