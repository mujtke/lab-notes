## Plan_A

### 1.算法框架

* （1）从程序中提取出中全局变量访问的信息，包括但不限于：[==访问方式==，==线程状态==，==锁集合==，==位置信息==，==函数调用栈==]等。

  * 线程状态包括线程集合以及threadStatus

  * 不使用BAM对CFA进行展开，**$\color{red}将线程创建视作函数调用$**（应该是特殊的函数调用），在展开的过程中提取访问信息。

  * 状态的覆盖关系中，利用线程状态和锁集合进行判断：

    $$ 若threadState(e_1)\ \ \sqsubseteq \ \ threadState(e_2)且lockState(e_1) \ \ \sqsubseteq\ \ lockState(e_2)，则e_1\sqsubseteq e_2，e_2\ \ \ cover\ \ e_1 $$

  * ==同名线程的创建尝试加以区分==，以t1为例，对于线程内的访问信息来说，第一次创建为t1_1，第二次创建为t1_2，对于主线程来说都为t1。

* （2）利用MHP分析筛选出可能存在race的访问对，MHP候选：`happen-before`。

* （3）$\color{red}对于可能存在race的pair，计算路径可达性$，若均可达，则报出race，否则需要进一步细化。
  * 无法找到所有可能的访问路径，因此此方案更倾向于找错
  * 对于初次判定不可达的race：
    * A.利用false race的路径产生的新谓词，重新开始继续迭代
    * B.不从头开始迭代，只关注false race的情况（找到路径不可达的原因，从对应位置处重新开始）

**可能的细化策略**：

* ==将不可行的race视作ERROR标签，变成多ERROR标签可达任务==
* ==ERROR标签匹配策略，单label（race中有一条路径不可达）和双label不同处理==



## Plan_B

算法框架与Plan_A类似，不同之处在于：

* ==在CFA展开过程中，只要发现一对可能的race就进行可行性分析==