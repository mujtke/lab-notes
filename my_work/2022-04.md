## 4.01 - 4.06

为Planc_C修改代码，从`CEGARAlgorithm`开始修改，先得到`Plan_C_Algorithm`的大致框架，然后在`Plan_C_Algorithm`的基础上修改相关的类，为了尽量不影响原来的代码，尽量将相关的类迁移到`my_lab`包下进行修改。能够直接复用（$\color{red}{不报异常}$）的类暂时没有修改，但是可能会有潜在的bug。



## 4.07

修改`Plan_C_UsageTransferRelation`



## 4.19

验证`analysis.threadOperationsTransform = true`的影响，在CPAchecker-2.0-base中测试，仅仅使用`BDDCPA`和`threadingCPA`，对于==thread_test16.i==来说，得到的ARG分别是：

* analysis.threadOperationsTransform = ***false***

==线程执行函数的语句没有出现在ARG中==

<img src="https://raw.githubusercontent.com/mujtke/pics/main/2022-04-19_17-20.png" style="zoom:80%;" />

* analysis.threadOperationsTransform = ***true***

arg中包含线程执行函数的语句，但是两个函数并不是==交错执行==的

![](https://raw.githubusercontent.com/mujtke/pics/main/2022-04-19_17-25.png)



* **不使用LocationCPA，同时关闭`analysis.threadOperationsTransform`选项和`analysis.traversal.useReversePostorder`选项**，能够得出正确的ARG：

<img src="https://raw.githubusercontent.com/mujtke/pics/main/2022-04-19_18-43.png" style="zoom:50%;" />



## 04.20

Usage中获取后继的方式是可达图构建失败的关键：`Plan_C_UsageTransferRelantion`中的`getAbstractSuccessor`

目前获取后继的方式更改为：

* 先从传入的状态pState中获取`AbstractStateWithLocaiotns`（Plan_C中对应`Plan_C_threadingState`），从该状态中可以获取到该状态对应的不同线程的Location（CFANode形式）

* 利用pState计算出后继状态，对每个后继状态同样可以获取到`AbstractStateWithLocaiotns`

* 每个后继状态与pState对应的`AbstractStateWithLocaiotns`进行对比，得到locations的变化：

  * 例如pState的`AbstractStateWithLocaiotns`对应的Locations：[N1, N2, N3]，而后继状态的`AbstractStateWithLocaiotns`对应的locations：[N1, N2, N5]

  则可以通过变化的位置，得到N3->N5的边，再利用该边进行usage相关的操作



## 04.21

在`Plan_C_Algorithm`中，当可达图探索完毕，但是还存在coveredState时，需要将其中由于Location覆盖导致的coveredStatesTable放回到waitlist中去（如果同时具有BDD覆盖，则该状态不会被放回）

状态放回时，如果仅仅将状态放回waitlist，主要小心：==被放回waitlist的状态会在reached中被抹去，因此需要将该状态连同精度一起放回reached中（放回时不要使用reached的add方法，该方法会将状态放回reached的同时将状态放回到waitlist中去）==

* coveredState应该满足的条件：**Location覆盖，但BDD不覆盖**。如果Location和BDD同时覆盖，则该状态直接被覆盖，不应该继续探索
